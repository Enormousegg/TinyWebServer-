# Tiny Web Server



### 线程同步机制封装类

#### RAII(resource acquisition is initialization)

​	用类来管理资源，将资源或者状态和对象的生命周期绑定，通过C++语言机制，实现资源和状态的安全管理，比如智能指针

> C++中的智能指针：
>
> 1. `std::unique_ptr<T>` ：独占资源所有权的指针。
>
> 2. `std::shared_ptr<T>` ：共享资源所有权的指针。
>
> 3. `std::weak_ptr<T>` ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。
>
>    [智能指针详解]: https://zhuanlan.zhihu.com/p/150555165
>
> 

#### 信号量（sv）

等待（p）操作：若sv大于0，则将其减1；若sv值为0，则挂起执行

信号（v）操作：如果有其它进行因为等待sv而挂起，则唤醒；若没有则直接将sv加1

> - sem_init函数用于初始化一个未命名的信号量
> - sem_destory函数用于销毁信号量
> - sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞
> - sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程

#### 互斥

互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,解锁并唤醒等待该互斥锁的线程

> - pthread_mutex_init函数用于初始化互斥锁
> - pthread_mutex_destory函数用于销毁互斥锁
> - pthread_mutex_lock函数以原子操作方式给互斥锁加锁
> - pthread_mutex_unlock函数以原子操作方式给互斥锁解锁

**死锁**

> **死锁的主要原因：**
>
> - 系统资源不足；
> - 程序执行的顺序有问题；
> - 资源分配不当等。

> **死锁的四个必要条件：**
>
> - 互斥条件：一个资源每次只能被一个进程使用。
> - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
> - 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
> - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
>
> 一般情况下破坏避免第四个条件来防止互锁发生

#### 条件变量

条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程

> - pthread_cond_init函数用于初始化条件变量
> - pthread_cond_destory函数销毁条件变量
> - pthread_cond_broadcast函数以广播的方式唤醒**所有**等待目标条件变量的线程
> - pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. **也就是说函数内部会有一次解锁和加锁操作**.

### 半同步半反应堆线程池

#### 服务器编程基本框架

![image-20220408093640801](https://github.com/Enormousegg/TinyWebServerJack/blob/master/%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/image-20220408093640801.png)

主要由I/O单元，逻辑单元和网络存储单元组成，其中每个单元之间通过请求队列进行通信，从而协同完成任务。

1. I/O单元：用于处理客户端连接，读写网络数据
2. 逻辑单元：用于处理业务逻辑的线程
3. 网络存储单元：指本地数据库和文件等

#### 五种I/O模型

1. **阻塞IO**:调用者调用了某个函数，期间什么也不做，必须等这个函数返回才能进行下一步动作
2. **非阻塞IO**:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况
3. **信号驱动IO**:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号，然后处理IO事件
4. **IO复用**:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数
5. **异步IO**:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

> **注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。**

#### 事件处理模式

1. reactor模式中，主线程(**I/O处理单元**)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(**逻辑单元** )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由**同步I/O**实现。

   ![](D:\笔记\TinyWebServer\image-20220408095412875.png)

   > 1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。
   > 2. 主线程调用 epoll_wait 等待 socket 上有数据可读。
   > 3. 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程则将可读事件放入请求队列。
   > 4. 睡眠在请求队列上某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。
   > 5. 主线程调用 epoll_wait 等待 socket 可写。
   > 6. 当 socket 可写，epoll_wait 通知主线程。主线程则将可写事件放入请求队列。
   > 7. 睡眠在请求队列上某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。

   

2. proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由**异步I/O**实现。

   ![image-20220408095625403](D:\笔记\TinyWebServer\image-20220408095625403.png)

   > **异步 I/O 模型（以 aio_read 和 aio_write 为例）**
   >
   > 1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。
   > 2. 主线程继续处理其它逻辑。
   > 3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
   > 4. 应用程序预知先定义好的**信号处理函数**选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
   > 5. 主线程继续处理其它逻辑。
   > 6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
   > 7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。

#### 同步I/O模拟proactor模式

由于异步I/O并不成熟，实际中使用较少，这里将使用同步I/O模拟实现proactor模式。（如何模拟）

同步I/O模拟proactor的工作流程如下（epoll_wait为例）：

> - 主线程往epoll内核事件表注册socket上的读就绪事件。
> - 主线程调用epoll_wait等待socket上有数据可读
> - 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
> - 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
> - 主线程调用epoll_wait等待socket可写。
> - 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

#### 两个事件处理模式的实现及其优缺点

Reactor实现了一个**被动的事件分离和分发模型**，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；

Proactor实现了一个**主动的事件分离和分发模型**；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）

**优点：**

> - **Reactor实现相对简单**，对于耗时短的处理场景处理高效；
> - 操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；
> - 事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；
> - 事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来
> - **Proactor性能更高**，能够处理耗时长的并发场景；

**缺点：**

> - Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；
> - Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；

**适用场景：**

> - Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；
> - Proactor：异步接收和同时处理多个服务请求的事件驱动程序；

#### 并发编程模式

并发编程的目的是让程序“同时”执行多个任务，提高效率。当一个程序是**计算密集型**的时，并发编程并没有优势，反而由于任务的切换时效率降低。但是，当一个程序是**ＩＯ密集型**时，采用并发编程会极大地提高cpu的利用率。因为**IO操作的速度远远小于cpu的计算速度**，所以让程序阻塞与IO操作上会浪费大量的CPU时间。而并发编程可以让阻塞于IO操作的线程主动放弃CPU，将执行权转移到其他线程。

> 同步与异步的概念：
> **IO模型：**同步和异步区分的是内核向应用进程通知的是就绪事件(同步)还是完成事件(异步)；
> **并发模式：**同步指的是，完全按照代码的顺序执行；异步指的是，程序的执行需要系统事件来驱动，比如：中断或信号。

#### 半同步/半异步模式

**原因：**

异步线程（按异步方式运行的线程）的**执行效率高**，实时性强，但是相对复杂，**不适合大量并发**；而同步线程（按同步方式运行的线程）虽然讲**效率不高**，但是**逻辑简单**。所以，对于服务器来说既要有高并发，实时性还要好的来说，应该同时使用同步线程和异步线程，即半同步/半异步模式。

**半同步/半异步模式工作流程**

> - 同步线程用于处理客户逻辑
> - 异步线程用于处理I/O事件
> - 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
> - 请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

**半同步/半反应堆工作流程（以Proactor模式为例）**

![image-20220408131035002](D:\笔记\TinyWebServer\image-20220408131035002.png)

> - 主线程充当异步线程，负责监听所有socket上的事件
> - 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
> - 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
> - 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

**高效的半同步/半异步模式**

![image-20220408131053585](D:\笔记\TinyWebServer\image-20220408131053585.png)

> - 主线成只管监听socket，连接socket有工作线程来管理
> - 当有新的连接到来时，主线程就接受并将新返回的连接socket派发给某个工作线程
> - 该工作线程负责socket上的所有IO操作，直到客户端关闭
> - **总结：**每个线程都维护着自己的事件循环，各自监听不同的事件。因此，在这种高效的模式中，每个线程都工作在异步模式，并非是严格的半同步/半异步模式。

#### 线程池

> - 空间换时间,用服务器的硬件资源,换取运行效率.
> - 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.
> - 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.
> - 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.

**适用场合：**

> - 单位时间内处理任务频繁而且任务处理时间短
> - 对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建

**线程池分析**

线程池的设计模式为**半同步/半反应堆**，其中反应堆具体为**Proactor事件处理模式**。

具体的，主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。

#### 静态成员

静态成员和普通成员（函数与变量）区别：

> - 普通数据成员属于类的一个具体的对象，只有对象被创建了，普通数据成员才会被分配内存。而静态数据成员属于整个类，即使没有任何对象创建，类的静态数据成员变量也存在。
> - 因为类的静态数据成员的存在不依赖与于任何类对象的存在，类的静态数据成员应该在代码中被显式地初始化，一般要在类外进行。
> - 外部访问类的静态成员能直接通过类名来访问
> - 类的静态成员函数无法直接访问普通数据成员（可以通过参数传递的方式访问），而类的任何成员函数都可以访问类的静态数据成员
> - 静态成员和类的普通成员一样，也具有public、protected、private3种访问级别，也可以具有返回值、const修饰符等参数。
> - 静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针

### HTTP连接处理

#### EPOLL

> **int epoll_create(int size)**：区分是哪创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size给内核提示事件表需要多大。
>
> **int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)**：该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除
>
> > - epfd：为epoll_creat的句柄
> >
> > - op：表示动作，用3个宏来表示：
> >
> > - - EPOLL_CTL_ADD (注册新的fd到epfd)，
> >   - EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，
> >   - EPOLL_CTL_DEL (从epfd删除一个fd)；
> >
> > - event：告诉内核需要监听的事件，使用例子：epoll_event event.events = EPOLLIN|EPOLLOUT
> >
> >   ```c++
> >   struct epoll_event {
> >   __uint32_t events; /* Epoll events */
> >   epoll_data_t data; /* User data variable */
> >   };
> >   ```
> >
> >   - events描述事件类型，其中epoll事件类型有以下几种
> >
> >   - - EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
> >     - EPOLLOUT：表示对应的文件描述符可以写
> >     - EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
> >     - EPOLLERR：表示对应的文件描述符发生错误
> >     - EPOLLHUP：表示对应的文件描述符被挂断；
> >     - EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
> >     - EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
>
> **int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)**：该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数
>
> > - events：用来存内核得到事件的集合，
> >
> > - maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，
> >
> > - timeout：是超时时间
> >
> > - - -1：阻塞
> >   - 0：立即返回，非阻塞
> >   - \>0：指定毫秒
> >
> > - 返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1

|         系统调用         |                            select                            |                             poll                             |                            epoll                             |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|         调用函数         |                           一个函数                           |                           一个函数                           |                           一组函数                           |
|      文件描述符数量      | select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024 | poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目（65535） | epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改 |
| 文件描述符从用户传给内核 |       将所有文件描述符拷贝到内核态，每次调用都需要拷贝       |       将所有文件描述符拷贝到内核态，每次调用都需要拷贝       | epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上 |
| 内核判断就绪的文件描述符 |    通过遍历文件描述符集合，判断哪个文件描述符上有事件发生    |    通过遍历文件描述符集合，判断哪个文件描述符上有事件发生    | epoll_create建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，触发list中fd的回调函数，得到对应事件 |
|         工作模式         |                 只能工作在相对低效的LT模式下                 |                 只能工作在相对低效的LT模式下                 | 可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 |
|         应用场景         | 当监测的fd数目较小，且各个fd都比较活跃或者当所有的fd都是活跃连接 | 当监测的fd数目较小，且各个fd都比较活跃或者当所有的fd都是活跃连接 | 当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态 |

**ET、LT、EPOLLONESHOT**

> - LT水平触发模式
>
> - - epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
>   - 当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理
>
> - ET边缘触发模式（事件触发次数小于LT模式）
>
> - - epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件
>
>   - 必须要一次性将数据读取完，建议使用非阻塞I/O，读取到出现eagain（若为阻塞I/O，那么I/O操作会因为无后续事件而处于阻塞状态）
>
>     [为何非阻塞I/O]: https://www.cnblogs.com/lawliet12/p/13508057.html
>
> - EPOLLONESHOT
>
> - - 一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket
>   - 我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件**

#### HTTP报文格式

HTTP报文分为请求报文和响应报文两种，每种报文必须按照特有格式生成，才能被浏览器端识别。

其中，浏览器端向服务器发送的为请求报文，服务器处理后返回给浏览器端的为响应报文。

**请求报文**

> - **请求行**，用来说明请求类型,要访问的资源以及所使用的HTTP版本。
>   GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。
>
> - **请求头部**，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。
>
> - - HOST，给出请求资源所在服务器的域名。
>   - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。
>   - Accept，说明用户代理可处理的媒体类型。
>   - Accept-Encoding，说明用户代理支持的内容编码。
>   - Accept-Language，说明用户代理能够处理的自然语言集。
>   - Content-Type，说明实现主体的媒体类型。
>   - Content-Length，说明实现主体的大小。
>   - Connection，连接管理，可以是Keep-Alive或close。
>
> - **空行**，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。
>
> - **请求数据**也叫主体，可以添加任意的其他数据。

**响应报文**

> - **状态行**，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
>   第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。
> - **消息报头**，用来说明客户端要使用的一些附加信息。
>   第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。
> - **空行**，消息报头后面的空行是必须的。
> - **响应正文**，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。

#### **HTTP状态码**

HTTP有5种类型的状态码，具体的：

> - 1xx：指示信息--表示请求已接收，继续处理。
>
> - 2xx：成功--表示请求正常处理完毕。
>
> - - 200 OK：客户端请求被正常处理。
>   - 206 Partial content：客户端进行了范围请求。
>
> - 3xx：重定向--要完成请求必须进行更进一步的操作。
>
> - - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
>   - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。
>
> - 4xx：客户端错误--请求有语法错误，服务器无法处理请求。
>
> - - 400 Bad Request：请求报文存在语法错误。
>   - 403 Forbidden：请求被服务器拒绝。
>   - 404 Not Found：请求不存在，服务器上找不到请求的资源。
>
> - 5xx：服务器端错误--服务器处理请求出错。
>
> - - 500 Internal Server Error：服务器在执行请求时出现错误。

#### **有限状态机**

有限状态机，是一种抽象的理论模型，它能够把**有限个变量描述的状态变化过程**，以可构造可验证的方式呈现出来。有限状态机可以通过if-else,switch-case和函数指针来实现，从软件工程的角度看，主要是为了**封装逻辑**。

```c++
STATE_MACHINE(){
    State cur_State = type_A;
    while(cur_State != type_C){
        Package _pack = getNewPackage();
        switch(){
            case type_A:
                process_pkg_state_A(_pack);
                cur_State = type_B;
                break;
            case type_B:
                process_pkg_state_B(_pack);
                cur_State = type_C;
                break;
        }
    }
}
//该状态机包含三种状态：type_A，type_B和type_C。其中，type_A是初始状态，type_C是结束状态。
```

#### **http报文处理流程**

- 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer（缓冲区），将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。
- 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。
- 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。

#### 流程图与状态机

**从状态机负责读取报文的一行，主状态机负责对该行数据进行解析**，主状态机内部调用从状态机，从状态机驱动主状态机。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/6OkibcrXVmBH2ZO50WrURwTiaNKTH7tCia3AR4WeKu2EEzSgKibXzG4oa4WaPfGutwBqCJtemia3rc5V1wupvOLFjzQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"  />

**主状态机**：三种状态，标识解析位置

> - CHECK_STATE_REQUESTLINE，解析请求行
> - CHECK_STATE_HEADER，解析请求头
> - CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

**从状态机**：三种状态，标识解析一行的读取状态。

> - LINE_OK，完整读取一行
> - LINE_BAD，报文语法有误
> - LINE_OPEN，读取的行不完整

各子线程通过process函数对任务进行处理，调用process_read函数和process_write函数分别完成报文解析与报文响应两个任务。



#### **Process_read函数解析**

**HTTP_CODE**表示HTTP请求的处理结果，在头文件中初始化了八种情形，在报文解析时只涉及到七种。

- **NO_REQUEST**

- - 请求不完整，需要继续读取请求报文数据
  - 跳转主线程继续监测读事件

- **GET_REQUEST**

- - 获得了完整的HTTP请求
  - 调用do_request完成请求资源映射

- **NO_RESOURCE**

- - 请求资源不存在
  - 跳转process_write完成响应报文

- **BAD_REQUEST**

- - HTTP请求报文有语法错误或请求资源为目录
  - 跳转process_write完成响应报文

- **FORBIDDEN_REQUEST**

- - 请求资源禁止访问，没有读取权限
  - 跳转process_write完成响应报文

- **FILE_REQUEST**

- - 请求资源可以正常访问
  - 跳转process_write完成响应报文

- **INTERNAL_ERROR**

- - 服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发

**解析报文整体流程**：

process_read通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。

- 判断条件
- - 主状态机转移到CHECK_STATE_CONTENT，该条件涉及解析消息体
  - 从状态机转移到LINE_OK，该条件涉及解析请求行和请求头部
  - 两者为或关系，当条件为真则继续循环，否则退出
- 循环体
- - 从状态机读取数据
  - 调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text
  - 主状态机解析text

#### 服务器响应报文

**基础API**：

**stat**：用于取得指定文件的文件属性，并将文件属性存储在结构体stat里，这里仅对其中用到的成员进行介绍。

```c++
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

//获取文件属性，存储在statbuf中
int stat(const char *pathname, struct stat *statbuf);

struct stat 
{
   mode_t    st_mode;        /* 文件类型和权限 */
   off_t     st_size;        /* 文件大小，字节数*/
};
```

**mmap**：用于将一个文件或其他对象映射到内存，提高文件的访问速度。

```c++
void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
int munmap(void* start,size_t length);
```

> - start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址
>
> - length：映射区的长度
>
> - prot：期望的内存保护标志，不能与文件的打开模式冲突
>
> - - PROT_READ 表示页内容可以被读取
>
> - flags：指定映射对象的类型，映射选项和映射页是否可以共享
>
> - - MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件
>
> - fd：有效的文件描述符，一般是由open()函数返回
>
> - off_toffset：被映射对象内容的起点

**iovec**:定义了一个向量元素，通常，这个结构用作一个多元素的数组。

```c++
struct iovec {
    void      *iov_base;      /* starting address of buffer */
    size_t    iov_len;        /* size of buffer */
};
```

> iov_base指向数据的地址
>
> iov_len表示数据的长度

**writev**:用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。

```c++
#include <sys/uio.h>
ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);
```

> - filedes表示文件描述符
> - iov为前述io向量机制结构体iovec
> - iovcnt为结构体的个数



![image-20220414153353488](D:\笔记\TinyWebServer\image-20220414153353488.png)

#### **do_request逻辑分析**

process_read函数的返回值是对请求的文件分析后的结果，一部分是语法错误导致的BAD_REQUEST，一部分是do_request的返回结果.该函数将网站根目录和url文件拼接，然后通过**stat判断该文件属性**。另外，为了**提高访问速度**，通过mmap进行映射，将普通文件映射到内存逻辑地址。

为了更好的理解请求资源的访问流程，这里对各种各页面跳转机制进行简要介绍。其中，浏览器网址栏中的字符，即url，可以将其抽象成ip:port/xxx，xxx通过html文件的action属性进行设置。

m_url为请求报文中解析出的请求资源，以/开头，也就是/xxx，项目中解析后的m_url有8种情况。

> - /
>
> - - GET请求，跳转到judge.html，即欢迎访问页面
>
> - /0
>
> - - POST请求，跳转到register.html，即注册页面
>
> - /1
>
> - - POST请求，跳转到log.html，即登录页面
>
> - /2CGISQL.cgi
>
> - - POST请求，进行登录校验
>   - 验证成功跳转到welcome.html，即资源请求成功页面
>   - 验证失败跳转到logError.html，即登录失败页面
>
> - /3CGISQL.cgi
>
> - - POST请求，进行注册校验
>   - 注册成功跳转到log.html，即登录页面
>   - 注册失败跳转到registerError.html，即注册失败页面
>
> - /5
>
> - - POST请求，跳转到picture.html，即图片请求页面
>
> - /6
>
> - - POST请求，跳转到video.html，即视频请求页面
>
> - /7
>
> - - POST请求，跳转到fans.html，即关注页面

#### **process_write逻辑详解**

根据`do_request`的返回状态，服务器子线程调用`process_write`向`m_write_buf`中写入响应报文。

> - add_status_line函数，添加状态行：http/1.1 状态码 状态消息
>
> - add_headers函数添加消息报头，内部调用add_content_length和add_linger函数
>
> - - content-length记录响应报文长度，用于浏览器端判断服务器是否发送完数据
>   - connection记录连接状态，用于告诉浏览器端保持长连接
>
> - add_blank_line添加空行

上述涉及的5个函数，均是内部调用`add_response`函数更新`m_write_idx`指针和缓冲区`m_write_buf`中的内容。



#### 具体代码细节

```

```

### 定时器处理非活动连接

#### 基础知识

- **非活跃**：是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。
- **定时事件**：是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。
- **定时器**：是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。
- **定时器容器**：是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。

#### 整体概述

本项目中，服务器主循环为**每一个连接创建一个定时器**，并对每个连接进行定时。另外，利用**升序时间链表容器**将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。

> Linux下提供了三种定时的方法:
>
> - socket选项SO_RECVTIMEO和SO_SNDTIMEO
> - SIGALRM信号
> - I/O复用系统调用的超时参数

本项目采用SIGALRM信号，利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。

> 一为定时方法与信号通知流程，
>
> 二为定时器及其容器设计与定时任务的处理。

**SIGALRM相关API**：

```c++
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
```

> - sa_handler是一个函数指针，指向信号处理函数
>
> - sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息
>
> - sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号
>
> - sa_flags用于指定信号处理的行为
>
> - - SA_RESTART，使被信号打断的系统调用自动重新发起
>   - SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号
>   - SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程
>   - SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号
>   - SA_RESETHAND，信号处理之后重新设置为默认的处理方式
>   - SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数
>
> - sa_restorer一般不使用

```c++
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

> - signum表示操作的信号。
> - act表示对信号设置新的处理方式。
> - oldact表示信号原来的处理方式。
> - 返回值，0 表示成功，-1 表示有错误发生。

```c++
#include <signal.h>
//用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。
int sigfillset(sigset_t *set);


#define SIGALRM  14     //由alarm系统调用产生timer时钟信号
#define SIGTERM  15     //终端发送的终止信号


#include <unistd.h>;

/*设置信号传送闹钟，即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程。如果未设置信号SIGALRM的处理函数，那么alarm()默认处理终止进程.*/
unsigned int alarm(unsigned int seconds);


#include <sys/types.h>
#include <sys/socket.h>

int socketpair(int domain, int type, int protocol, int sv[2]);
/*domain表示协议族，PF_UNIX或者AF_UNIX
type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
protocol表示类型，只能为0
sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
返回结果， 0为创建成功，-1为创建失败*/


#include <sys/types.h>
#include <sys/socket.h>
/*当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。*/
ssize_t send(int sockfd, const void *buf, size_t len, int flags)
```



#### 信号通知流程

Linux下的信号采用的**异步处理机制**，信号处理函数和当前进程是两条不同的执行路线。具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。

为**避免信号竞态现象**发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。

一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数**执行时间过长**，会导致**信号屏蔽太久**。

这里的**解决方案**是，信号处理函数仅仅发送信号通知程序主循环，将信号对应的**处理逻辑放在程序主循环中**，由主循环执行信号对应的逻辑代码。

- **统一事件源**：统一事件源，是指将信号事件与其他事件一样被处理。

  > 信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I/O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。

- **信号处理机制**：每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来标识对应的信号类型。

  ![image-20220418140424502](D:\笔记\TinyWebServer\image-20220418140424502.png)

  > - 信号的接收
  >- - 接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。
  > - 信号的检测
  >- - 进程从内核态返回到用户态前进行信号检测
  >   - 进程在内核态中，从睡眠状态被唤醒的时候进行信号检测
  >  - 进程陷入内核态后，有两种场景会对信号进行检测：
  >   - 当发现有新信号时，便会进入下一步，信号的处理。
  > - 信号的处理
  > - - ( **内核** )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。
  >   - ( **用户** )接下来进程返回到用户态中，执行相应的信号处理函数。
  >  - ( **内核** )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。
  >   - ( **用户** )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。
  >- （如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行）

#### 代码解析

```

```

### 日志

#### 基础知识

**日志**，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。

**同步日志**，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。

**生产者-消费者模型**，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。

**阻塞队列**，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。

**异步日志**，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。

**单例模式**，最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。

#### 整体概述

本项目中，使用**单例模式创建日志系统**，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用**同步和异步写入两种**方式。

其中异步写入方式，将**生产者-消费者模型封装为阻塞队列**，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

> 一是单例模式与阻塞队列的定义
>
> 二是日志类的定义与使用

#### 单例模式

单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。

**单例模式分类**：区别在于创建实例的时间不同

- 懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）
- 饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）

**单例类特点：**

- 构造函数和析构函数为**private**类型，目的**禁止**外部构造和析构
- 拷贝构造和赋值构造函数为**private**类型，目的是**禁止**外部拷贝和赋值，确保实例的唯一性
- 类里有个获取实例的**静态函数**，可以全局访问

> **实现单例模式的步骤**
>
> 1. 构造函数私有化
> 2. 增加静态私有的当前类的指针变量
> 3. 提供静态对外接口，让用户获得单例对象

[各种单例详解]: https://blog.csdn.net/qq_34827674/article/details/100166215

**经典的线程安全懒汉模式**

```c++
class single{
private:
    //私有静态指针变量指向唯一实例
    static single *p;

    //静态锁，是由于静态函数只能访问静态成员
    static pthread_mutex_t lock;

    //私有化构造函数
    single(){
        pthread_mutex_init(&lock, NULL);
    }
    ~single(){}

public:
    //公有静态方法获取实例
    static single* getinstance();

};

pthread_mutex_t single::lock;

single* single::p = NULL;
single* single::getinstance(){
    /*如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合NULL == p的情况，直接返回已创建好的实例。*/
   if (NULL == p){
        pthread_mutex_lock(&lock);
        if (NULL == p){
            p = new single;
        }
        pthread_mutex_unlock(&lock);
    }
    return p;
}
```

**局部静态变量之线程安全懒汉模式**

```c++
class single{
private:
    single(){}
    ~single(){}

public:
    static single* getinstance();

};

single* single::getinstance(){
    static single obj;
    return &obj;
}
```

**饿汉模式**

```c++
class single{
private:
    static single* p;
    single(){}
    ~single(){}

public:
    static single* getinstance();

};
single* single::p = new single();
single* single::getinstance(){
    return p;
}

//测试方法
int main(){

    single *p1 = single::getinstance();
    single *p2 = single::getinstance();

    if (p1 == p2)
        cout << "same" << endl;

    system("pause");
    return 0;
}
/*饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。*/
```

#### 条件变量与生产者-消费者模型

**条件变量**提供了一种线程间的通知机制，当某个共享数据达到某个值时,唤醒等待这个共享数据的线程

**基础API**

> - pthread_cond_init函数，用于初始化条件变量
> - pthread_cond_destory函数，销毁条件变量
> - pthread_cond_broadcast函数，以广播的方式唤醒**所有**等待目标条件变量的线程
> - pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， **也就是说函数内部会有一次解锁和加锁操作**.

**生产者和消费者是互斥关系**，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。

**阻塞队列**：阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。阻塞队列中，使用了循环数组实现了队列，作为两者共享缓冲区，当然了，队列也可以使用STL中的queue。

```

```

**基础API**：描述fputs，可变参数宏_____VA_ARGS_____，fflush

```c++
#include <stdio.h>
int fputs(const char *str, FILE *stream);
/*str，一个数组，包含了要写入的以空字符终止的字符序列。
stream，指向FILE对象的指针，该FILE对象标识了要被写入字符串的流。*/


/*__VA_ARGS__是一个可变参数的宏，定义时宏定义中参数列表的最后一个参数为省略号，在实际使用时会发现有时会加##，有时又不加。*/
#define my_print1(...)  printf(__VA_ARGS__)

/*搭配va_list的format使用
__VA_ARGS__宏前面加上##的作用在于，当可变参数的个数为0时，这里printf参数列表中的的##会把前面多余的","去掉，否则会编译出错，建议使用后面这种，使得程序更加健壮。*/
#define my_print2(format, ...) printf(format, __VA_ARGS__)  
#define my_print3(format, ...) printf(format, ##__VA_ARGS__)


#include <stdio.h>
int fflush(FILE *stream);
/*fflush()会强迫将缓冲区内的数据写回参数stream 指定的文件中，如果参数stream 为NULL，fflush()会将所有打开的文件数据更新。

在使用多个输出函数连续进行多次输出到控制台时，有可能下一个数据再上一个数据还没输出完毕，还在输出缓冲区中时，下一个printf就把另一个数据加入输出缓冲区，结果冲掉了原来的数据，出现输出错误。
在prinf()后加上fflush(stdout); 强制马上输出到控制台，可以避免出现上述错误。*/
```

#### 流程图与日志类定义

![image-20220420100011762](D:\笔记\TinyWebServer\image-20220420100011762.png)

**流程图**

- 日志文件

- - 局部变量的懒汉模式获取实例
  - 生成日志文件，并判断同步和异步写入方式

- 同步

- - 判断是否分文件
  - 直接格式化输出内容，将信息写入日志文件

- 异步

- - 判断是否分文件
  - 格式化输出内容，将内容写入阻塞队列，创建一个写线程，从阻塞队列取出内容写入日志文件

```

```



### 数据库连接池

**数据库连接池定义**：

> 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。通俗来说，**池是资源的容器，本质上是对资源的复用**。连接池中的资源为**一组数据库连接**，由程序动态地对池中的连接进行使用，释放。当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，**无需动态分配**；当服务器处理完一个客户连接后,可以把相关的资源放回池中，**无需执行系统调用释放资源**。

**数据库访问一般流程**：

先系统创建数据库连接，完成数据库操作，然后系统断开数据库连接。

**为何数据库连接池：**

- 从一般流程中可以看出，若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。
- 在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。

#### 项目数据库连接池模块

项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能。具体的，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还连接池。

本项目中使用**单例模式和链表创建数据库连接池**，实现对数据库连接资源的复用。

**具体实现**：

- **单例模式创建**，结合代码描述连接池的单例实现。
- **连接池代码实现**，结合代码对连接池的外部访问接口进行详解。
- **RAII机制释放数据库连接**，描述连接释放的封装逻辑。

**单例模式**

本项目采用下述C++11局部静态变量懒汉单例模式（线程安全）

```c++
//懒汉模式创建单例
class connection_pool
{
public:
    //局部静态变量单例模式
    //使用指针而不是引用是为了避免拷贝构造函数进行拷贝
    static connection_pool *GetInstance();

private:
    connection_pool();
    ~connection_pool();
}

connection_pool *connection_pool::GetInstance()
{
    static connection_pool connPool;
    return &connPool;
}
```

**连接池实现**：主要有初始化，获取连接、释放连接，销毁连接池。

```

```

### 注册登录

使用**数据库连接池**实现服务器访问数据库的功能，使用**POST请求**完成注册和登录的校验工作。

> **流程图**，描述服务器从报文中提取出用户名密码，并完成注册和登录校验后，实现页面跳转的逻辑。
>
> **载入数据库表**，结合代码将数据库中的数据载入到服务器中。
>
> **提取用户名和密码**，结合代码对报文进行解析，提取用户名和密码。
>
> **注册登录流程**，结合代码对描述服务器进行注册和登录校验的流程。
>
> **页面跳转**，结合代码对页面跳转机制进行详解。

![image-20220420104309726](D:\笔记\TinyWebServer\image-20220420104309726.png)

```

```

